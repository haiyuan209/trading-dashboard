<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Options Trading Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        :root {
            --bg-dark: #0a0e1a;
            --bg-card: #151b2d;
            --border: #2d3748;
            --text-main: #e2e8f0;
            --text-muted: #94a3b8;
            --accent-green: #10b981;
            --accent-red: #ef4444;
            --accent-blue: #3b82f6;
            --accent-yellow: #f59e0b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-dark);
            color: var(--text-main);
            padding: 10px;
            overflow-x: hidden;
        }

        .container {
            width: 100%;
            max-width: 100vw;
            margin: 0;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: var(--bg-card);
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        h1 {
            font-size: 1.8rem;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .btn-group {
            display: flex;
            gap: 0;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border);
        }

        .btn-toggle {
            padding: 8px 18px;
            background: var(--bg-dark);
            border: none;
            color: var(--text-muted);
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.25s;
            border-right: 1px solid var(--border);
            white-space: nowrap;
        }

        .btn-toggle:last-child {
            border-right: none;
        }

        .btn-toggle:hover {
            background: rgba(96, 165, 250, 0.1);
            color: var(--text-main);
        }

        .btn-toggle.active {
            background: linear-gradient(135deg, rgba(96, 165, 250, 0.25), rgba(16, 185, 129, 0.15));
            color: #60a5fa;
            box-shadow: inset 0 -2px 0 0 #60a5fa;
        }

        .ticker-selector {
            position: relative;
            width: 350px;
        }

        #ticker-search {
            width: 100%;
            padding: 12px 40px 12px 15px;
            background: var(--bg-dark);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-main);
            font-size: 1rem;
            font-weight: 600;
        }

        #ticker-search:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .search-icon {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
            pointer-events: none;
        }

        /* Heatmap View Styles */
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: var(--bg-card);
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        select,
        button {
            padding: 8px 15px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text-main);
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }

        select:hover,
        button:hover {
            background: #1a1a2a;
            border-color: var(--accent-blue);
        }

        .heatmap-container {
            display: flex;
            gap: 10px;
            width: 100%;
            height: calc(100vh - 180px);
            align-items: flex-start;
            overflow: auto;
        }

        .heatmap-grid {
            flex: 1;
            background: #0a0a0a;
            padding: 10px;
            border-radius: 8px;
            width: 100%;
        }

        .grid-header {
            display: flex;
            margin-bottom: 5px;
        }

        .strike-label {
            width: 70px;
            text-align: right;
            padding-right: 10px;
            font-size: 13px;
            font-weight: bold;
            flex-shrink: 0;
            color: var(--text-main);
        }

        .exp-header {
            flex: 1;
            min-width: 80px;
            text-align: center;
            font-size: 13px;
            font-weight: bold;
            padding: 8px;
            border-bottom: 2px solid #444;
        }

        .grid-row {
            display: flex;
            margin-bottom: 2px;
        }

        .cell {
            flex: 1;
            min-width: 80px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            position: relative;
            border: 1px solid #222;
        }

        .cell:hover {
            border-color: #fff;
            z-index: 10;
        }

        .legend-inline {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
            flex-shrink: 0;
        }

        /* Analytics View Styles */
        .ticker-info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .info-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 15px;
        }

        .info-label {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.3rem;
            font-weight: 700;
        }

        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .card-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--accent-blue);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }

        .chart-container {
            position: relative;
            height: 350px;
            margin-top: 15px;
        }

        .calc-results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .metric {
            padding: 12px;
            background: var(--bg-dark);
            border-radius: 8px;
            border-left: 4px solid var(--accent-blue);
        }

        .metric-label {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 1.3rem;
            font-weight: 700;
        }

        .metric-value.positive {
            color: var(--accent-green);
        }

        .metric-value.negative {
            color: var(--accent-red);
        }

        input[type="number"] {
            width: 100%;
            padding: 12px;
            background: var(--bg-dark);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-main);
            font-size: 1rem;
            font-weight: 600;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .hedge-actions {
            margin-top: 20px;
        }

        .action-item {
            padding: 10px;
            background: var(--bg-dark);
            border-left: 4px solid var(--accent-yellow);
            margin-bottom: 8px;
            border-radius: 4px;
        }

        .action-trigger {
            font-weight: 600;
            color: var(--accent-yellow);
        }

        .action-detail {
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-top: 3px;
        }

        .hidden {
            display: none !important;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-muted);
        }

        /* Staleness Banner */
        .staleness-banner {
            display: none;
            background: linear-gradient(90deg, rgba(239, 68, 68, 0.15), rgba(239, 68, 68, 0.05));
            border: 1px solid var(--accent-red);
            border-radius: 8px;
            padding: 10px 20px;
            margin-bottom: 15px;
            color: var(--accent-red);
            font-weight: 600;
            font-size: 0.9rem;
            align-items: center;
            gap: 10px;
        }

        .staleness-banner.visible {
            display: flex;
        }

        /* GEX Profile View */
        .gex-profile-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .gex-profile-container .card {
            margin-bottom: 0;
        }

        /* Alerts Panel */
        .alert-item {
            padding: 10px 15px;
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .alert-item.critical {
            background: rgba(239, 68, 68, 0.15);
            border-left: 4px solid var(--accent-red);
        }

        .alert-item.warning {
            background: rgba(251, 191, 36, 0.15);
            border-left: 4px solid var(--accent-yellow);
        }

        .alert-item.info {
            background: rgba(59, 130, 246, 0.15);
            border-left: 4px solid var(--accent-blue);
        }

        .alert-time {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* Multi-ticker comparison */
        .compare-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }

        .compare-controls input {
            width: 120px;
        }

        /* Plays Tab */
        .plays-table {
            width: 100%;
            border-collapse: collapse;
        }

        .plays-table th {
            text-align: left;
            padding: 12px 10px;
            border-bottom: 2px solid var(--border);
            color: var(--text-muted);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            user-select: none;
        }

        .plays-table th:hover {
            color: var(--accent-blue);
        }

        .plays-table td {
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .plays-table tr:hover {
            background: rgba(59, 130, 246, 0.06);
        }

        .score-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-weight: 700;
            font-size: 0.95rem;
            min-width: 42px;
            text-align: center;
        }

        .score-badge.high {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .score-badge.med {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }

        .score-badge.low {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .dir-tag {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .dir-tag.BULLISH {
            background: rgba(16, 185, 129, 0.15);
            color: #10b981;
        }

        .dir-tag.BEARISH {
            background: rgba(239, 68, 68, 0.15);
            color: #ef4444;
        }

        .dir-tag.NEUTRAL {
            background: rgba(59, 130, 246, 0.15);
            color: #3b82f6;
        }

        .signal-breakdown {
            font-size: 0.78rem;
            color: var(--text-muted);
            margin-top: 6px;
        }

        .signal-bar {
            display: inline-block;
            height: 6px;
            border-radius: 3px;
            margin-right: 2px;
            vertical-align: middle;
        }

        .plays-disclaimer {
            padding: 10px 16px;
            margin-bottom: 15px;
            border-radius: 8px;
            background: rgba(251, 191, 36, 0.08);
            border: 1px solid rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            font-size: 0.8rem;
        }

        .auto-refresh-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: var(--accent-green);
            margin-left: 15px;
        }

        .auto-refresh-indicator .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-green);
            animation: pulse-dot 2s ease-in-out infinite;
        }

        @keyframes pulse-dot {

            0%,
            100% {
                opacity: 0.4;
            }

            50% {
                opacity: 1;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <h1>üìä Options Trading Dashboard</h1>
                <div class="btn-group" id="view-buttons">
                    <button class="btn-toggle active" data-view="heatmap">üó∫Ô∏è Heatmap</button>
                    <button class="btn-toggle" data-view="analytics">üìä Analytics</button>
                    <button class="btn-toggle" data-view="gex-profile">üìà GEX Profile</button>
                    <button class="btn-toggle" data-view="plays">üéØ Plays</button>
                    <button class="btn-toggle" data-view="alerts">üîî Alerts</button>
                </div>
            </div>
            <div class="ticker-selector">
                <input type="text" id="ticker-search" placeholder="Select ticker..." autocomplete="off">
                <span class="search-icon">üîç</span>
            </div>
        </div>

        <!-- Heatmap View -->
        <div id="heatmap-view">
            <div class="controls"
                style="display: flex; align-items: center; justify-content: flex-start; flex-wrap: wrap; gap: 15px;">
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div class="btn-group" id="greek-buttons">
                        <button class="btn-toggle active" data-greek="GEX">Gamma (GEX)</button>
                        <button class="btn-toggle" data-greek="VEX">Vega (VEX)</button>
                    </div>
                    <button onclick="refreshHeatmapData()">Refresh</button>
                </div>
                <div id="footer"
                    style="flex: 1; text-align: center; color: var(--accent-blue); font-size: 0.9rem; font-weight: 500;">
                </div>
                <div class="legend-inline">
                    <span style="font-size: 0.75rem; color: var(--text-muted);">Scale:</span>
                    <div id="legend-content" style="display: flex; align-items: center; gap: 6px;"></div>
                </div>
            </div>

            <div class="heatmap-container">
                <div class="heatmap-grid">
                    <div id="heatmap"></div>
                </div>
            </div>
        </div>

        <!-- Staleness Warning Banner -->
        <div id="staleness-banner" class="staleness-banner">
            <span>‚ö†Ô∏è</span>
            <span id="staleness-msg">Data may be stale</span>
        </div>
    </div>

    <!-- Analytics View -->
    <div id="analytics-view" class="hidden">
        <div style="max-width: 1800px; margin: 0 auto;">
            <div id="ticker-info" class="ticker-info-panel" style="display: none;"></div>

            <div id="loading" class="loading">
                <div>Loading analytics data...</div>
            </div>

            <div id="dashboard-content" style="display: none;">
                <!-- Hedging Calculator -->
                <div class="card">
                    <div class="card-title">‚ö° Market Maker Hedging Scenarios</div>
                    <div style="margin-bottom: 15px; color: var(--text-muted); font-size: 0.9rem;">
                        As price moves, market makers must dynamically hedge their positions:
                    </div>
                    <div class="calc-results" id="calc-results"></div>
                    <div class="hedge-actions" id="hedge-actions"></div>
                </div>

                <div class="grid">
                    <div class="card">
                        <div class="card-title">üí∞ Gamma Exposure (GEX)</div>
                        <div class="chart-container">
                            <canvas id="gexChart"></canvas>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-title">‚öñÔ∏è Delta Exposure</div>
                        <div class="chart-container">
                            <canvas id="deltaChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- GEX Profile View -->
    <div id="gex-profile-view" class="hidden" style="max-width:1800px;margin:0 auto;">
        <div class="gex-profile-container">
            <div class="card">
                <div class="card-title">üìà Net GEX by Strike</div>
                <div class="chart-container" style="height:400px;"><canvas id="gexProfileChart"></canvas></div>
            </div>
            <div class="card">
                <div class="card-title">‚öñÔ∏è Put/Call OI Ratio by Strike</div>
                <div class="chart-container" style="height:400px;"><canvas id="pcRatioChart"></canvas></div>
            </div>
        </div>
        <div class="card" style="margin-top:20px;">
            <div class="card-title">üîÑ Multi-Ticker GEX Comparison</div>
            <div class="compare-controls">
                <input type="text" id="compare-t1" placeholder="Ticker 1" value="SPY"
                    style="padding:8px;background:var(--bg-dark);border:1px solid var(--border);border-radius:6px;color:var(--text-main);">
                <input type="text" id="compare-t2" placeholder="Ticker 2" value="QQQ"
                    style="padding:8px;background:var(--bg-dark);border:1px solid var(--border);border-radius:6px;color:var(--text-main);">
                <input type="text" id="compare-t3" placeholder="Ticker 3" value="IWM"
                    style="padding:8px;background:var(--bg-dark);border:1px solid var(--border);border-radius:6px;color:var(--text-main);">
                <button onclick="loadMultiTicker()" style="padding:8px 16px;">Compare</button>
            </div>
            <div class="chart-container" style="height:400px;"><canvas id="compareChart"></canvas></div>
        </div>
    </div>

    <!-- Plays View -->
    <div id="plays-view" class="hidden" style="max-width:1400px;margin:0 auto;">
        <div class="plays-disclaimer">‚ö†Ô∏è NOT financial advice. Scores reflect signal strength for
            educational/informational purposes only. Always do your own research.</div>
        <div class="card">
            <div class="card-title">üéØ Trade Recommendations <span class="auto-refresh-indicator"><span
                        class="dot"></span>Live</span></div>
            <div id="plays-list">
                <div class="loading">Loading recommendations...</div>
            </div>
        </div>
    </div>

    <!-- Alerts View -->
    <div id="alerts-view" class="hidden" style="max-width:1200px;margin:0 auto;">
        <div class="card">
            <div class="card-title">üîî Recent Alerts</div>
            <div id="alerts-list">
                <div class="loading">Loading alerts...</div>
            </div>
        </div>
    </div>

    <!-- Data Sources -->

    <script src="option_data.js"></script>
    <script src="all_tickers_data.js"></script>
    <script src="ticker_metadata.js"></script>

    <script>
        // Global state
        let currentView = 'heatmap';
        let currentTicker = null;
        let charts = {};
        let heatmapData = [];
        let analyticsData = {};
        let dataTimestamp = null;
        const API_BASE = window.location.origin;
        const STALENESS_MINUTES = 5;

        // Initialize on load
        window.addEventListener('load', async () => {
            await initializeData();
            initializeViewSwitcher();
            initializeTickerSearch();
            setInterval(checkStaleness, 30000); // Check every 30s
        });

        async function initializeData() {
            // Try API first, fall back to static JS files
            let apiSuccess = false;
            try {
                const healthResp = await fetch(`${API_BASE}/api/health`);
                if (healthResp.ok) {
                    const health = await healthResp.json();
                    dataTimestamp = health.last_updated;
                    apiSuccess = true;
                    console.log('[API] Server responding, loading from API');
                }
            } catch (e) {
                console.log('[API] Server not available, using static JS files');
            }

            // Load heatmap data
            if (typeof OPTION_DATA !== 'undefined') {
                heatmapData = OPTION_DATA;
                console.log('[OK] Loaded heatmap data:', heatmapData.length, 'contracts');
            }

            // Load analytics data
            if (typeof TICKER_DATA !== 'undefined') {
                const rawData = TICKER_DATA.data || {};
                for (let ticker in rawData) {
                    analyticsData[ticker] = {
                        price: rawData[ticker].price,
                        timestamp: rawData[ticker].timestamp,
                        strikes: {}
                    };
                    for (let strikeKey in rawData[ticker].strikes) {
                        const numericKey = parseFloat(strikeKey);
                        analyticsData[ticker].strikes[numericKey] = rawData[ticker].strikes[strikeKey];
                    }
                    if (!dataTimestamp) dataTimestamp = rawData[ticker].timestamp;
                }
                console.log('[OK] Loaded analytics data:', Object.keys(analyticsData).length, 'tickers');
            }
            checkStaleness();
        }

        function initializeViewSwitcher() {
            document.querySelectorAll('#view-buttons .btn-toggle').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#view-buttons .btn-toggle').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentView = btn.dataset.view;
                    switchView();
                });
            });
        }

        function switchView() {
            const views = ['heatmap-view', 'analytics-view', 'gex-profile-view', 'plays-view', 'alerts-view'];
            views.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.classList.add('hidden');
            });

            if (currentView === 'heatmap') {
                document.getElementById('heatmap-view').classList.remove('hidden');
                if (currentTicker) loadHeatmapData(currentTicker);
            } else if (currentView === 'analytics') {
                document.getElementById('analytics-view').classList.remove('hidden');
                if (currentTicker) loadAnalyticsData(currentTicker);
            } else if (currentView === 'gex-profile') {
                document.getElementById('gex-profile-view').classList.remove('hidden');
                if (currentTicker) loadGexProfile(currentTicker);
            } else if (currentView === 'plays') {
                document.getElementById('plays-view').classList.remove('hidden');
                loadPlays();
            } else if (currentView === 'alerts') {
                document.getElementById('alerts-view').classList.remove('hidden');
                loadAlerts();
            }
        }

        // Normalise user input: strip leading '$' and uppercase
        function normalizeTicker(raw) {
            return raw.replace(/^\$/, '').toUpperCase().trim();
        }

        // Build (or rebuild) the ticker suggestion list from loaded data
        function getAvailableTickers() {
            const heatmapTickers = [...new Set(heatmapData.map(d => d.Symbol))];
            const analyticsTickers = Object.keys(analyticsData);
            return [...new Set([...heatmapTickers, ...analyticsTickers])].sort();
        }

        function rebuildTickerSuggestions() {
            const allTickers = getAvailableTickers();
            let datalist = document.getElementById('ticker-suggestions');
            if (!datalist) {
                datalist = document.createElement('datalist');
                datalist.id = 'ticker-suggestions';
                document.body.appendChild(datalist);
                document.getElementById('ticker-search').setAttribute('list', 'ticker-suggestions');
            }
            datalist.innerHTML = '';
            allTickers.forEach(ticker => {
                const option = document.createElement('option');
                option.value = ticker;
                datalist.appendChild(option);
            });
            console.log('[Search] Available tickers:', allTickers.length, allTickers.slice(0, 10));
            return allTickers;
        }

        function initializeTickerSearch() {
            const searchInput = document.getElementById('ticker-search');
            const allTickers = rebuildTickerSuggestions();

            // Search on Enter key
            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const value = normalizeTicker(e.target.value);
                    const available = getAvailableTickers();
                    console.log('[Search] Enter pressed, searching for:', value);
                    if (available.includes(value)) {
                        console.log('[Search] Ticker found! Selecting:', value);
                        selectTicker(value);
                    } else {
                        console.log('[Search] Ticker not found:', value, '(available:', available.length, ')');
                        // Show error feedback
                        searchInput.style.borderColor = 'var(--accent-red)';
                        searchInput.setAttribute('placeholder', value + ' not found ‚Äî try without $');
                        setTimeout(() => {
                            searchInput.style.borderColor = '';
                            searchInput.setAttribute('placeholder', 'Select ticker...');
                        }, 2000);
                    }
                }
            });

            // Auto-select on exact match while typing
            searchInput.addEventListener('input', (e) => {
                const value = normalizeTicker(e.target.value);
                const available = getAvailableTickers();
                if (value.length > 0 && available.includes(value)) {
                    selectTicker(value);
                }
            });

            // Set first ticker as default
            if (allTickers.length > 0) {
                console.log('[Search] Setting default ticker:', allTickers[0]);
                selectTicker(allTickers[0]);
            }
        }

        function selectTicker(ticker) {
            console.log('[Select] Switching to ticker:', ticker, 'View:', currentView);
            currentTicker = ticker;
            const searchInput = document.getElementById('ticker-search');
            searchInput.value = ticker;

            // Visual feedback that ticker was selected
            searchInput.style.backgroundColor = 'rgba(16, 185, 129, 0.1)';
            setTimeout(() => {
                searchInput.style.backgroundColor = '';
            }, 500);

            if (currentView === 'heatmap') {
                loadHeatmapData(ticker);
            } else if (currentView === 'analytics') {
                loadAnalyticsData(ticker);
            } else if (currentView === 'gex-profile') {
                loadGexProfile(ticker);
            }
        }

        // ===== HEATMAP VIEW FUNCTIONS =====

        let currentGreek = 'GEX';

        document.querySelectorAll('#greek-buttons .btn-toggle').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('#greek-buttons .btn-toggle').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentGreek = btn.dataset.greek;
                if (currentTicker) loadHeatmapData(currentTicker);
            });
        });

        function loadHeatmapData(ticker) {
            const tickerData = heatmapData.filter(r => r.Symbol === ticker);
            if (tickerData.length === 0) {
                document.getElementById('heatmap').innerHTML = '<div style="padding: 40px; text-align: center; color: var(--text-muted);">No heatmap data for ' + ticker + '</div>';
                return;
            }

            generateHeatmap(tickerData);
        }

        function generateHeatmap(tickerData) {
            const spotPrice = tickerData[0].UnderlyingPrice || tickerData[0].Last || 100;
            const expirations = [...new Set(tickerData.map(r => r.Expiration))].sort().slice(0, 10);

            // Get all unique strikes and limit to 50 centered around spot price
            const allStrikes = [...new Set(tickerData.map(r => r.Strike))].sort((a, b) => b - a);

            // Find the strike closest to spot price
            let closestIndex = 0;
            let minDiff = Math.abs(allStrikes[0] - spotPrice);
            for (let i = 1; i < allStrikes.length; i++) {
                const diff = Math.abs(allStrikes[i] - spotPrice);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIndex = i;
                }
            }

            // Get 25 strikes above and 25 strikes below the spot price
            const startIndex = Math.max(0, closestIndex - 25);
            const endIndex = Math.min(allStrikes.length, startIndex + 50);
            const strikes = allStrikes.slice(startIndex, endIndex);

            // Build data matrix
            const matrix = {};
            const gammaMatrix = {};
            strikes.forEach(strike => {
                matrix[strike] = {};
                gammaMatrix[strike] = {};
                expirations.forEach(exp => {
                    const contracts = tickerData.filter(r => r.Strike === strike && r.Expiration === exp);
                    let totalExposure = 0;
                    let netGEX = 0;

                    contracts.forEach(c => {
                        const exposure = calculateExposure(c, currentGreek, spotPrice);
                        const gamma = c.Gamma || 0;
                        const oi = c.OpenInterest || 0;

                        totalExposure += c.Type === 'CALL' ? exposure : -exposure;
                        const gex = gamma * oi * 100 * spotPrice;
                        netGEX += c.Type === 'CALL' ? gex : -gex;
                    });

                    matrix[strike][exp] = totalExposure;
                    gammaMatrix[strike][exp] = netGEX;
                });
            });

            // Find min/max for color scaling
            let allValues = [];
            strikes.forEach(strike => {
                expirations.forEach(exp => {
                    allValues.push(matrix[strike][exp]);
                });
            });

            // Calculate statistics separately for positive and negative values
            const positiveValues = allValues.filter(v => v > 0);
            const negativeValues = allValues.filter(v => v < 0);

            // Calculate mean and std dev for positive values
            let posStats = { mean: 0, stdDev: 0, max: 0 };
            if (positiveValues.length > 0) {
                posStats.max = Math.max(...positiveValues);
                posStats.mean = positiveValues.reduce((a, b) => a + b, 0) / positiveValues.length;
                const variance = positiveValues.reduce((sum, val) => sum + Math.pow(val - posStats.mean, 2), 0) / positiveValues.length;
                posStats.stdDev = Math.sqrt(variance);
            }

            // Calculate mean and std dev for negative values
            let negStats = { mean: 0, stdDev: 0, min: 0 };
            if (negativeValues.length > 0) {
                negStats.min = Math.min(...negativeValues);
                negStats.mean = negativeValues.reduce((a, b) => a + b, 0) / negativeValues.length;
                const variance = negativeValues.reduce((sum, val) => sum + Math.pow(val - negStats.mean, 2), 0) / negativeValues.length;
                negStats.stdDev = Math.sqrt(variance);
            }


            renderGrid(strikes, expirations, matrix, gammaMatrix, posStats, negStats, spotPrice);
            updateFooter(spotPrice);
            updateLegend(posStats.max, negStats.min);
        }

        function calculateExposure(contract, greek, spotPrice) {
            const oi = contract.OpenInterest || 0;
            const multiplier = 100;

            if (greek === 'GEX') {
                const gamma = contract.Gamma || 0;
                // Standard Net GEX: Gamma √ó OI √ó 100 √ó Spot
                return gamma * oi * multiplier * spotPrice;
            } else if (greek === 'VEX') {
                const vega = contract.Vega || 0;
                return vega * oi * multiplier;
            } else if (greek === 'DEX') {
                const delta = contract.Delta || 0;
                return delta * oi * multiplier * spotPrice;
            }
            return 0;
        }

        function renderGrid(strikes, expirations, matrix, gammaMatrix, posStats, negStats, spotPrice) {
            const heatmap = document.getElementById('heatmap');

            // Find the strike closest to spot price (ATM strike)
            let atmStrike = strikes[0];
            let minDiff = Math.abs(strikes[0] - spotPrice);
            strikes.forEach(strike => {
                const diff = Math.abs(strike - spotPrice);
                if (diff < minDiff) {
                    minDiff = diff;
                    atmStrike = strike;
                }
            });

            // Find max positive and max negative values for star indicators
            // Exclude zeros from consideration
            let absMaxPositive = -Infinity;
            let absMaxNegative = Infinity;
            let maxPosKey = null;
            let maxNegKey = null;

            strikes.forEach(strike => {
                expirations.forEach(exp => {
                    const value = matrix[strike][exp];
                    if (value > absMaxPositive && value !== 0) {
                        absMaxPositive = value;
                        maxPosKey = `${strike}-${exp}`;
                    }
                    if (value < absMaxNegative && value !== 0) {
                        absMaxNegative = value;
                        maxNegKey = `${strike}-${exp}`;
                    }
                });
            });

            let html = '<div class="grid-header">';
            html += '<div class="strike-label">Strike</div>';
            expirations.forEach(exp => {
                const date = exp ? exp.split('T')[0] : 'Unknown';
                html += `<div class="exp-header">${date}</div>`;
            });
            html += '</div>';

            strikes.forEach(strike => {
                // Check if this is the ATM strike
                const isATM = strike === atmStrike;
                const rowStyle = isATM ? ' style="border-left: 4px solid #FFD700;"' : '';

                html += `<div class="grid-row"${rowStyle}>`;

                // Highlight ATM strike label
                const strikeLabelStyle = isATM ? ' style="font-weight: bold; color: #FFD700;"' : '';
                html += `<div class="strike-label"${strikeLabelStyle}>${strike.toFixed(1)}</div>`;

                expirations.forEach(exp => {
                    const value = matrix[strike][exp];
                    const gamma = gammaMatrix[strike][exp];

                    // If value is 0, render empty cell
                    if (value === 0) {
                        html += `<div class="cell" style="background-color: rgb(20, 20, 20);" title="Strike: ${strike}, Exp: ${exp}, No exposure"></div>`;
                    } else {
                        const color = getColor(value, posStats, negStats);
                        const cellKey = `${strike}-${exp}`;

                        // Add star indicator for extreme values
                        let star = '';
                        if (cellKey === maxPosKey && absMaxPositive > 0) {
                            star = '<span style="color: #FFD700;">‚≠ê</span> '; // Yellow star for max positive (LEFT of value)
                        } else if (cellKey === maxNegKey && absMaxNegative < 0) {
                            star = '<span style="color: #000000;">‚òÖ</span> '; // Black star for max negative (LEFT of value)
                        }

                        const displayValue = formatGamma(value);
                        html += `<div class="cell" style="background-color: ${color};" title="Strike: ${strike}, Exp: ${exp}, ${currentGreek}: ${formatValue(value)}, Net GEX: ${formatGamma(gamma)}">${star}${displayValue}</div>`;
                    }
                });
                html += '</div>';
            });

            heatmap.innerHTML = html;
        }

        function getColor(value, posStats, negStats) {
            if (value === 0) return 'rgb(20, 20, 20)';

            if (value > 0) {
                // Positive: Use z-score (standard deviations from mean)
                // Map z-scores to colors: 0œÉ = dark green, 1œÉ = medium green, 2œÉ+ = yellow
                const zScore = posStats.stdDev > 0 ? (value - posStats.mean) / posStats.stdDev : 0;
                const clampedZ = Math.min(Math.max(zScore, -2), 3); // Clamp to reasonable range


                // Normalize z-score to 0-1 range (treat -2œÉ to +3œÉ as our range)
                const normalized = (clampedZ + 2) / 5; // -2 -> 0, +3 -> 1

                if (normalized >= 0.7) {
                    // High positive (>1.5œÉ above mean) - Yellow/orange for outliers
                    const factor = (normalized - 0.7) / 0.3;
                    const r = Math.floor(160 + (180 - 160) * factor);  // Orange-yellow
                    const g = Math.floor(120 + (140 - 120) * factor);
                    const b = Math.floor(30 + (20 - 30) * factor);
                    return `rgb(${r}, ${g}, ${b})`;
                } else if (normalized >= 0.4) {
                    // Medium positive (near mean to +1œÉ) - DARK green
                    const factor = (normalized - 0.4) / 0.3;
                    const r = Math.floor(0 + (160 - 0) * factor);      // Transitioning to yellow
                    const g = Math.floor(100 + (120 - 100) * factor);  // Dark green base
                    const b = Math.floor(50 + (30 - 50) * factor);
                    return `rgb(${r}, ${g}, ${b})`;
                } else {
                    // Low positive (below mean) - LIGHT green
                    const factor = normalized / 0.4;
                    const r = Math.floor(100 + (0 - 100) * factor);
                    const g = Math.floor(200 + (100 - 200) * factor);  // Light to dark green
                    const b = Math.floor(120 + (50 - 120) * factor);
                    return `rgb(${r}, ${g}, ${b})`;
                }
            } else {
                // Negative: Use z-score (standard deviations from mean)
                // Map z-scores to colors: 0œÉ = light blue, -1œÉ = medium blue, -2œÉ+ = purple
                const zScore = negStats.stdDev > 0 ? (value - negStats.mean) / negStats.stdDev : 0;
                const clampedZ = Math.min(Math.max(zScore, -3), 2); // Clamp to reasonable range

                // Normalize z-score to 0-1 range (treat -3œÉ to +2œÉ as our range)
                const normalized = (clampedZ + 3) / 5; // -3 -> 0, +2 -> 1

                // Invert for negatives (more negative = higher score)
                const inverted = 1 - normalized;

                if (inverted >= 0.7) {
                    // High negative (<-1.5œÉ below mean) - Dark purple zone
                    const factor = (inverted - 0.7) / 0.3;
                    const r = Math.floor(75 - (75 - 60) * factor);   // Darker purple
                    const g = Math.floor(50 * (1 - factor));
                    const b = Math.floor(140 - (140 - 110) * factor); // Darker purple
                    return `rgb(${r}, ${g}, ${b})`;
                } else if (inverted >= 0.4) {
                    // Medium negative (near mean to -1œÉ) - Darker blue zone
                    const factor = (inverted - 0.4) / 0.3;
                    const r = Math.floor(70 - (70 - 75) * factor);
                    const g = Math.floor(120 - (120 - 50) * factor);  // Much darker
                    const b = Math.floor(160 - (160 - 140) * factor); // Darker blue
                    return `rgb(${r}, ${g}, ${b})`;
                } else {
                    // Low negative (above mean) - Dark blue instead of light blue
                    const factor = inverted / 0.4;
                    const r = Math.floor(80 - 10 * factor);
                    const g = Math.floor(130 - 10 * factor);  // Much darker than 200
                    const b = Math.floor(170 - 10 * factor);  // Much darker than 255
                    return `rgb(${r}, ${g}, ${b})`;
                }
            }
        }

        function formatValue(value) {
            const abs = Math.abs(value);
            if (abs === 0) return '$0.0K';
            if (abs >= 1000000) return `${value >= 0 ? '' : '-'}$${(abs / 1000000).toFixed(1)}M`;
            if (abs >= 1000) return `${value >= 0 ? '' : '-'}$${(abs / 1000).toFixed(1)}K`;
            return `${value >= 0 ? '' : '-'}$${abs.toFixed(0)}`;
        }

        function formatGamma(gamma) {
            const abs = Math.abs(gamma);
            if (abs === 0) return '0';
            // Always use K notation for consistency with comma separators
            if (abs >= 1000) {
                const kValue = (abs / 1000).toFixed(1);
                const withCommas = parseFloat(kValue).toLocaleString('en-US', { minimumFractionDigits: 1, maximumFractionDigits: 1 });
                return `${gamma >= 0 ? '+' : '-'}${withCommas}K`;
            }
            return `${gamma >= 0 ? '+' : '-'}${abs.toFixed(0)}`;
        }

        function updateFooter(spotPrice) {
            const footer = document.getElementById('footer');
            const timestamp = new Date().toLocaleString();
            footer.innerHTML = `${currentTicker} ${currentGreek} ‚Äî ${timestamp} ‚Äî Current Price: $${spotPrice.toFixed(2)}`;
        }

        function updateLegend(maxAbs) {
            const legend = document.getElementById('legend-content');
            legend.innerHTML = `
                <span style="font-size: 0.7rem; color: var(--text-muted);">-${formatValue(maxAbs)}</span>
                <div style="width: 180px; height: 12px; border-radius: 4px; background: linear-gradient(to right, rgb(74, 20, 140), rgb(0, 188, 212), rgb(0, 128, 128), rgb(76, 175, 80), rgb(170, 215, 0), rgb(255, 215, 0));"></div>
                <span style="font-size: 0.7rem; color: var(--text-muted);">+${formatValue(maxAbs)}</span>
            `;
        }

        function refreshHeatmapData() {
            if (currentTicker) loadHeatmapData(currentTicker);
        }


        // ===== ANALYTICS VIEW FUNCTIONS =====

        function loadAnalyticsData(ticker) {
            const data = analyticsData[ticker];
            if (!data) {
                document.getElementById('loading').innerHTML = '<div style="padding: 40px; text-align: center; color: var(--text-muted);">No analytics data for ' + ticker + '</div>';
                return;
            }

            document.getElementById('loading').style.display = 'none';
            document.getElementById('dashboard-content').style.display = 'block';

            updateTickerInfo(data);
            updateCalculator(data);
            updateCharts(data);
        }

        function updateTickerInfo(data) {
            const infoPanel = document.getElementById('ticker-info');
            const strikes = data.strikes || {};
            const strikeCount = Object.keys(strikes).length;
            const totalOI = Object.values(strikes).reduce((sum, s) => sum + (s.oi || 0), 0);

            infoPanel.innerHTML = `
                <div class="info-card">
                    <div class="info-label">Current Price</div>
                    <div class="info-value" style="color: var(--accent-blue);">$${data.price.toFixed(2)}</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Strikes Available</div>
                    <div class="info-value">${strikeCount}</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Total OI</div>
                    <div class="info-value">${totalOI.toLocaleString()}</div>
                </div>
            `;
            infoPanel.style.display = 'grid';
        }

        function updateCalculator(data) {
            const price = data.price;
            const strikes = data.strikes || {};
            const strikeKeys = Object.keys(strikes).map(Number).sort((a, b) => a - b);

            // Find key strikes near current price
            const nearbyStrikes = strikeKeys.filter(s => Math.abs(s - price) / price <= 0.10).sort((a, b) => a - b);

            // Calculate total positioning
            let totalDelta = 0, totalGamma = 0;
            strikeKeys.forEach(strike => {
                const s = strikes[strike];
                totalDelta += s.total_delta || 0;
                totalGamma += s.total_gamma || 0;
            });

            const dealerDelta = -totalDelta;
            const dealerGamma = -totalGamma;

            const resultsHTML = `
                <div class="metric">
                    <div class="metric-label">Dealer Position</div>
                    <div class="metric-value ${dealerDelta > 0 ? 'positive' : 'negative'}">
                        ${dealerDelta > 0 ? 'LONG' : 'SHORT'} ${Math.abs(dealerDelta).toLocaleString(undefined, { maximumFractionDigits: 0 })}
                    </div>
                </div>
                <div class="metric">
                    <div class="metric-label">Gamma Stance</div>
                    <div class="metric-value ${dealerGamma > 0 ? 'positive' : 'negative'}">
                        ${dealerGamma > 0 ? 'LONG' : 'SHORT'} Œì
                    </div>
                </div>
                <div class="metric">
                    <div class="metric-label">Current Price</div>
                    <div class="metric-value" style="color: var(--accent-blue);">$${price.toFixed(2)}</div>
                </div>
            `;

            document.getElementById('calc-results').innerHTML = resultsHTML;

            // Generate detailed hedging scenarios
            let scenariosHTML = '<h4 style="color: var(--accent-yellow); margin-bottom: 15px;">üìç Key Strike Levels & Market Maker Actions:</h4>';

            // Group strikes into zones
            const abovePrice = nearbyStrikes.filter(s => s > price).slice(0, 3);
            const belowPrice = nearbyStrikes.filter(s => s < price).reverse().slice(0, 3);

            if (belowPrice.length > 0) {
                belowPrice.forEach(strike => {
                    const strikeData = strikes[strike];
                    const gamma = Math.abs(strikeData.total_gamma || 0);
                    const delta = strikeData.total_delta || 0;
                    const distance = ((price - strike) / price * 100).toFixed(1);

                    scenariosHTML += `
                        <div class="action-item" style="border-left-color: var(--accent-red);">
                            <div class="action-trigger">üí• As price drops ${distance}% to $${strike.toFixed(2)}</div>
                            <div class="action-detail">
                                <strong style="color: var(--accent-green);">Market Maker Action: BUY shares</strong><br>
                                ‚Ä¢ Gamma: ${gamma.toFixed(4)} - Requires hedging ${(gamma * 100).toFixed(0)} shares per $1 move<br>
                                ‚Ä¢ Put options become more ITM, dealers long puts must buy underlying<br>
                                ‚Ä¢ This creates <strong>supportive buying pressure</strong> as price approaches
                            </div>
                        </div>
                    `;
                });
            }

            if (abovePrice.length > 0) {
                abovePrice.forEach(strike => {
                    const strikeData = strikes[strike];
                    const gamma = Math.abs(strikeData.total_gamma || 0);
                    const delta = strikeData.total_delta || 0;
                    const distance = ((strike - price) / price * 100).toFixed(1);

                    scenariosHTML += `
                        <div class="action-item" style="border-left-color: var(--accent-green);">
                            <div class="action-trigger">üöÄ As price rallies ${distance}% to $${strike.toFixed(2)}</div>
                            <div class="action-detail">
                                <strong style="color: var(--accent-red);">Market Maker Action: SELL shares</strong><br>
                                ‚Ä¢ Gamma: ${gamma.toFixed(4)} - Requires hedging ${(gamma * 100).toFixed(0)} shares per $1 move<br>
                                ‚Ä¢ Call options become more ITM, dealers short calls must sell underlying<br>
                                ‚Ä¢ This creates <strong>resistance/selling pressure</strong> at this level
                            </div>
                        </div>
                    `;
                });
            }

            const gammaStance = dealerGamma > 0 ? "long" : "short";
            scenariosHTML += `
                <div style="margin-top: 20px; padding: 15px; background: var(--bg-dark); border-radius: 8px; border-left: 4px solid var(--accent-blue);">
                    <div style="font-weight: 600; color: var(--accent-blue); margin-bottom: 8px;">üí° Market Maker Implications:</div>
                    <div style="color: var(--text-muted); font-size: 0.9rem; line-height: 1.6;">
                        ‚Ä¢ Dealers are currently <strong>${gammaStance} gamma</strong>, meaning they ${dealerGamma > 0 ? 'STABILIZE price' : 'AMPLIFY moves'}<br>
                        ‚Ä¢ ${dealerGamma > 0 ? 'They buy dips and sell rallies (supportive)' : 'They sell into weakness and buy into strength (destabilizing)'}<br>
                        ‚Ä¢ Watch these strikes as magnets - price often gravitates toward high gamma levels
                    </div>
                </div>
            `;

            document.getElementById('hedge-actions').innerHTML = scenariosHTML;
        }

        function updateCharts(data) {
            const strikes = data.strikes || {};
            const strikeKeys = Object.keys(strikes).map(Number).sort((a, b) => a - b);
            const price = data.price;

            const filteredStrikes = strikeKeys.filter(s => Math.abs(s - price) / price <= 0.15);

            if (filteredStrikes.length < 3) {
                const warning = '<div style="padding: 40px; text-align: center; color: var(--text-muted);">Limited data for charts</div>';
                document.querySelectorAll('.chart-container').forEach(container => {
                    container.innerHTML = warning;
                });
                return;
            }

            const gammaData = filteredStrikes.map(s => strikes[s].total_gamma || 0);
            const deltaData = filteredStrikes.map(s => strikes[s].total_delta || 0);

            // Calculate GEX (Gamma Exposure) for each strike
            const gexData = filteredStrikes.map(s => {
                const gamma = strikes[s].total_gamma || 0;
                const oi = strikes[s].oi || 0;
                return gamma * oi * 100 * s; // GEX = Gamma √ó OI √ó 100 √ó Strike Price
            });

            // Destroy existing charts
            Object.values(charts).forEach(chart => chart?.destroy());

            // Reset containers
            document.getElementById('gexChart').parentElement.innerHTML = '<canvas id="gexChart"></canvas>';
            document.getElementById('deltaChart').parentElement.innerHTML = '<canvas id="deltaChart"></canvas>';

            // Create GEX chart
            charts.gex = new Chart(document.getElementById('gexChart'), {
                type: 'bar',
                data: {
                    labels: filteredStrikes.map(s => '$' + s.toFixed(0)),
                    datasets: [{
                        label: 'Gamma Exposure (GEX)',
                        data: gexData,
                        backgroundColor: gexData.map(v => v >= 0 ? 'rgba(16, 185, 129, 0.7)' : 'rgba(239, 68, 68, 0.7)'),
                        borderColor: gexData.map(v => v >= 0 ? '#10b981' : '#ef4444'),
                        borderWidth: 2
                    }]
                },
                options: getChartOptions()
            });

            // Create Delta chart
            charts.delta = new Chart(document.getElementById('deltaChart'), {
                type: 'bar',
                data: {
                    labels: filteredStrikes.map(s => '$' + s.toFixed(0)),
                    datasets: [{
                        label: 'Delta',
                        data: deltaData,
                        backgroundColor: deltaData.map(v => v >= 0 ? 'rgba(16, 185, 129, 0.7)' : 'rgba(239, 68, 68, 0.7)'),
                        borderColor: deltaData.map(v => v >= 0 ? '#10b981' : '#ef4444'),
                        borderWidth: 2
                    }]
                },
                options: getChartOptions()
            });
        }

        function getChartOptions() {
            return {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false }
                },
                scales: {
                    x: {
                        grid: { color: '#2d3748' },
                        ticks: {
                            color: '#94a3b8',
                            maxRotation: 45,
                            minRotation: 45
                        }
                    },
                    y: {
                        grid: { color: '#2d3748' },
                        ticks: { color: '#94a3b8' }
                    }
                }
            };
        }

        // === STALENESS DETECTION ===
        function checkStaleness() {
            const banner = document.getElementById('staleness-banner');
            const msg = document.getElementById('staleness-msg');
            if (!dataTimestamp || !banner) return;

            const updated = new Date(dataTimestamp);
            const ageMs = Date.now() - updated.getTime();
            const ageMin = Math.round(ageMs / 60000);

            if (ageMin > STALENESS_MINUTES) {
                msg.textContent = `‚ö†Ô∏è Data is ${ageMin} minutes old (last updated: ${updated.toLocaleTimeString()}). May be stale.`;
                banner.classList.add('visible');
            } else {
                banner.classList.remove('visible');
            }
        }

        // === GEX PROFILE VIEW ===
        function loadGexProfile(ticker) {
            if (!ticker) return;
            const data = analyticsData[ticker];
            if (!data || !data.strikes) {
                console.warn('[GEX Profile] No data for', ticker);
                return;
            }

            const price = data.price || 0;
            const allStrikes = Object.keys(data.strikes).map(Number).sort((a, b) => a - b);
            // Filter to ¬±15% of price
            const lo = price * 0.85, hi = price * 1.15;
            const strikes = allStrikes.filter(s => s >= lo && s <= hi);

            // Net GEX per strike
            const gexVals = strikes.map(s => {
                const sd = data.strikes[s];
                return (sd.total_gamma || 0) * price * 100;
            });

            // Put/Call OI Ratio per strike from raw heatmap data
            const tickerContracts = heatmapData.filter(c => c.Symbol === ticker);
            const callOI = {}, putOI = {};
            tickerContracts.forEach(c => {
                const s = parseFloat(c.Strike);
                if (c.Type === 'CALL') callOI[s] = (callOI[s] || 0) + (c.OpenInterest || 0);
                else if (c.Type === 'PUT') putOI[s] = (putOI[s] || 0) + (c.OpenInterest || 0);
            });
            const pcRatios = strikes.map(s => {
                const co = callOI[s] || 0;
                const po = putOI[s] || 0;
                return co > 0 ? (po / co) : 0;
            });

            // Destroy old charts
            if (charts.gexProfile) charts.gexProfile.destroy();
            if (charts.pcRatio) charts.pcRatio.destroy();

            // GEX Profile Chart
            charts.gexProfile = new Chart(document.getElementById('gexProfileChart'), {
                type: 'bar',
                data: {
                    labels: strikes.map(s => '$' + s.toFixed(0)),
                    datasets: [{
                        label: `${ticker} Net GEX`,
                        data: gexVals,
                        backgroundColor: gexVals.map(v => v >= 0 ? 'rgba(16,185,129,0.7)' : 'rgba(239,68,68,0.7)'),
                        borderColor: gexVals.map(v => v >= 0 ? '#10b981' : '#ef4444'),
                        borderWidth: 1
                    }]
                },
                options: {
                    ...getChartOptions(),
                    plugins: {
                        legend: { display: true, labels: { color: '#e2e8f0' } },
                        annotation: price > 0 ? {
                            annotations: {
                                priceLine: {
                                    type: 'line', scaleID: 'x',
                                    value: '$' + Math.round(price),
                                    borderColor: '#fbbf24', borderWidth: 2, borderDash: [5, 5],
                                    label: { display: true, content: 'Price', color: '#fbbf24' }
                                }
                            }
                        } : {}
                    }
                }
            });

            // P/C Ratio Chart
            charts.pcRatio = new Chart(document.getElementById('pcRatioChart'), {
                type: 'bar',
                data: {
                    labels: strikes.map(s => '$' + s.toFixed(0)),
                    datasets: [{
                        label: 'Put/Call OI Ratio',
                        data: pcRatios,
                        backgroundColor: pcRatios.map(v => v > 1 ? 'rgba(239,68,68,0.6)' : 'rgba(59,130,246,0.6)'),
                        borderColor: pcRatios.map(v => v > 1 ? '#ef4444' : '#3b82f6'),
                        borderWidth: 1
                    }]
                },
                options: {
                    ...getChartOptions(),
                    plugins: {
                        legend: { display: true, labels: { color: '#e2e8f0' } },
                    }
                }
            });
        }

        // === MULTI-TICKER COMPARISON ===
        async function loadMultiTicker() {
            const t1 = document.getElementById('compare-t1').value.toUpperCase().trim();
            const t2 = document.getElementById('compare-t2').value.toUpperCase().trim();
            const t3 = document.getElementById('compare-t3').value.toUpperCase().trim();
            const tickers = [t1, t2, t3].filter(t => t && analyticsData[t]);

            if (charts.compare) charts.compare.destroy();

            const colors = ['#10b981', '#3b82f6', '#f59e0b'];
            const datasets = tickers.map((ticker, i) => {
                const data = analyticsData[ticker];
                const price = data.price || 0;
                const allStrikes = Object.keys(data.strikes).map(Number).sort((a, b) => a - b);
                const lo = price * 0.9, hi = price * 1.1;
                const strikes = allStrikes.filter(s => s >= lo && s <= hi);

                // Normalize strikes as % from price
                return {
                    label: ticker,
                    data: strikes.map(s => ({
                        x: ((s - price) / price * 100).toFixed(1) + '%',
                        y: (data.strikes[s].total_gamma || 0) * price * 100
                    })),
                    backgroundColor: colors[i] + '99',
                    borderColor: colors[i],
                    borderWidth: 1
                };
            });

            charts.compare = new Chart(document.getElementById('compareChart'), {
                type: 'bar',
                data: { datasets },
                options: {
                    ...getChartOptions(),
                    parsing: { xAxisKey: 'x', yAxisKey: 'y' },
                    plugins: { legend: { display: true, labels: { color: '#e2e8f0' } } }
                }
            });
        }

        // === ALERTS VIEW ===
        async function loadAlerts() {
            const list = document.getElementById('alerts-list');
            let alerts = [];

            // Try API first
            try {
                const resp = await fetch(`${API_BASE}/api/alerts/recent?hours=24`);
                if (resp.ok) {
                    const data = await resp.json();
                    alerts = data.alerts || [];
                }
            } catch (e) {
                console.log('[Alerts] API not available');
            }

            if (alerts.length === 0) {
                list.innerHTML = '<div class="loading">No recent alerts. Alerts appear here when GEX flips, gamma walls shift, or price approaches key levels.</div>';
                return;
            }

            list.innerHTML = alerts.map(a => {
                const sev = (a.alert_type === 'gex_flip') ? 'critical' :
                    (a.alert_type === 'price_near_wall') ? 'warning' : 'info';
                const time = new Date(a.timestamp).toLocaleString();
                return `<div class="alert-item ${sev}">
                    <div>${a.message}</div>
                    ${a.details ? `<div style="font-size:0.8rem;color:var(--text-muted);margin-top:4px;">${a.details}</div>` : ''}
                    <div class="alert-time">${time}</div>
                </div>`;
            }).join('');
        }
        // === PLAYS VIEW ===
        let playsSortField = 'score';
        let playsSortDir = -1; // -1 desc, 1 asc

        async function loadPlays() {
            const container = document.getElementById('plays-list');
            try {
                const resp = await fetch(`${API_BASE}/api/recommendations`);
                if (!resp.ok) throw new Error('API unavailable');
                const data = await resp.json();
                const recs = data.recommendations || [];

                if (recs.length === 0) {
                    container.innerHTML = '<div class="loading">No recommendations yet. Run the fetcher to generate plays.</div>';
                    return;
                }

                // Sort
                recs.sort((a, b) => {
                    if (playsSortField === 'score') return (a.score - b.score) * playsSortDir;
                    if (playsSortField === 'ticker') return a.ticker.localeCompare(b.ticker) * playsSortDir;
                    if (playsSortField === 'direction') return a.direction.localeCompare(b.direction) * playsSortDir;
                    return 0;
                });

                const arrow = playsSortDir === -1 ? ' ‚ñº' : ' ‚ñ≤';
                container.innerHTML = `
                    <table class="plays-table">
                        <thead><tr>
                            <th onclick="sortPlays('score')">Score${playsSortField === 'score' ? arrow : ''}</th>
                            <th onclick="sortPlays('ticker')">Ticker${playsSortField === 'ticker' ? arrow : ''}</th>
                            <th onclick="sortPlays('direction')">Direction${playsSortField === 'direction' ? arrow : ''}</th>
                            <th>Play Type</th>
                            <th>Reasoning</th>
                            <th>Risk</th>
                        </tr></thead>
                        <tbody>${recs.map(r => {
                    const sc = r.score >= 70 ? 'high' : r.score >= 40 ? 'med' : 'low';
                    // Build signal bars
                    const bars = (r.signals || []).map(s => {
                        const pct = s.max_score > 0 ? (s.score / s.max_score * 100) : 0;
                        const color = pct >= 70 ? '#10b981' : pct >= 40 ? '#fbbf24' : '#ef4444';
                        return `<span title="${s.name}: ${s.score}/${s.max_score} ‚Äî ${s.detail}" class="signal-bar" style="width:${Math.max(pct * 0.6, 4)}px;background:${color}"></span>`;
                    }).join('');
                    return `<tr>
                                <td><span class="score-badge ${sc}">${r.score}</span><div class="signal-breakdown">${bars}</div></td>
                                <td style="font-weight:700;color:var(--text-main)">${r.ticker}</td>
                                <td><span class="dir-tag ${r.direction}">${r.direction}</span></td>
                                <td style="color:var(--accent-blue);font-weight:500">${r.play_type}</td>
                                <td style="font-size:0.82rem;color:var(--text-muted);max-width:400px">${r.reasoning}</td>
                                <td style="font-size:0.78rem;color:#f59e0b;max-width:250px">${r.risk_notes}</td>
                            </tr>`;
                }).join('')}</tbody>
                    </table>`;
            } catch (e) {
                container.innerHTML = '<div class="loading">Recommendations unavailable. Start the API server and fetcher first.</div>';
            }
        }

        function sortPlays(field) {
            if (playsSortField === field) playsSortDir *= -1;
            else { playsSortField = field; playsSortDir = -1; }
            loadPlays();
        }

        // === AUTO-REFRESH (all views) ===
        const AUTO_REFRESH_INTERVAL = 30000; // 30 seconds
        let lastKnownUpdate = null;

        async function autoRefreshAll() {
            try {
                const resp = await fetch(`${API_BASE}/api/health`);
                if (!resp.ok) return;
                const health = await resp.json();

                // Only refresh if data actually changed
                if (health.last_updated && health.last_updated !== lastKnownUpdate) {
                    lastKnownUpdate = health.last_updated;
                    dataTimestamp = health.last_updated;
                    console.log('[Auto-Refresh] New data detected:', health.last_updated);

                    // Reload data from API
                    try {
                        const optResp = await fetch(`${API_BASE}/api/tickers`);
                        if (optResp.ok) {
                            const tickerData = await optResp.json();
                            const tickers = tickerData.tickers || [];

                            // Refresh analytics for all known tickers
                            for (const ticker of tickers) {
                                try {
                                    const aResp = await fetch(`${API_BASE}/api/analytics/${ticker}`);
                                    if (aResp.ok) {
                                        const aData = await aResp.json();
                                        if (aData.data) {
                                            analyticsData[ticker] = {
                                                price: aData.data.price,
                                                timestamp: aData.data.timestamp,
                                                strikes: {}
                                            };
                                            for (let sk in (aData.data.strikes || {})) {
                                                analyticsData[ticker].strikes[parseFloat(sk)] = aData.data.strikes[sk];
                                            }
                                        }
                                    }
                                } catch (e) { /* skip ticker */ }
                            }

                            // Refresh heatmap data for all tickers
                            const newHeatmap = [];
                            for (const ticker of tickers) {
                                try {
                                    const oResp = await fetch(`${API_BASE}/api/options/${ticker}`);
                                    if (oResp.ok) {
                                        const oData = await oResp.json();
                                        if (oData.contracts) newHeatmap.push(...oData.contracts);
                                    }
                                } catch (e) { /* skip ticker */ }
                            }
                            if (newHeatmap.length > 0) heatmapData = newHeatmap;
                        }
                    } catch (e) { console.log('[Auto-Refresh] Data reload failed'); }

                    // Rebuild ticker suggestions (picks up new tickers like SPX)
                    rebuildTickerSuggestions();

                    // Refresh the currently active view
                    refreshCurrentView();
                    checkStaleness();
                }
            } catch (e) {
                // API not available, skip
            }
        }

        function refreshCurrentView() {
            if (currentView === 'heatmap' && currentTicker) loadHeatmapData(currentTicker);
            else if (currentView === 'analytics' && currentTicker) loadAnalyticsData(currentTicker);
            else if (currentView === 'gex-profile' && currentTicker) loadGexProfile(currentTicker);
            else if (currentView === 'plays') loadPlays();
            else if (currentView === 'alerts') loadAlerts();
        }

        // Start auto-refresh polling
        setInterval(autoRefreshAll, AUTO_REFRESH_INTERVAL);
    </script>
</body>

</html>